import { useEffect, useState } from "react";

import { api, type RouterOutputs } from "utils/api";
import Comment from "components/Comment";
import NewCommentForm from "components/comment/NewCommentForm";

type CommentType = RouterOutputs["comments"]["getComments"][number];

export type CommentSectionProps = {
  shoeId: string;
};

export default function CommentSection({ shoeId }: CommentSectionProps) {
  const commentsQuery = api.comments.getComments.useQuery(
    { shoeId },
    {
      refetchOnWindowFocus: false,
      // TODO: implement optimistic updates, but idrk how to with react-query
      // _optimisticResults: "optimistic",
      // kinda implemented with `useState` below
    }
  );

  // How do we handle essentially updating the state of the comments? (`commentsQuery.data`)
  // We can't use `useState` because we need to update the state based on the response from the API
  // could use `useState` and then `useEffect` to update the state based on the response from the API, works :shrug:
  const [comments, setComments] = useState<CommentType[]>([]);

  // useMemo for sorting comments?

  // TODO: functionality to order comments by options, default datePosted
  // score asc/desc, date asc/desc
  // but then would need to handle score state in this component
  // not in Comment component as it is now

  // generated by copilot:
  // might need to use useReducer here, for example if you want to add a comment:
  // setComments([...comments, comment]);
  // but if you want to delete a comment:
  // setComments(comments.filter((comment) => comment.id !== id));
  // so you'd need to use a reducer to handle both cases
  // which would look like:
  //   const [comments, dispatchComments] = useReducer(commentsReducer, initialComments);
  // and then you'd have a commentsReducer function that handles both cases
  //   const commentsReducer = (state, action) => {
  //     switch (action.type) {
  //       case "add":
  //         return [...state, action.payload];
  //       case "delete":
  //         return state.filter((comment) => comment.id !== action.payload);
  //       default:
  //         return state;
  //     }
  //   }
  // with types:
  //   type CommentsState = CommentAreaComment[];
  //   type CommentsAction =
  //     | { type: "add"; payload: CommentAreaComment }
  //     | { type: "delete"; payload: string };
  //   const commentsReducer = (state: CommentsState, action: CommentsAction) => {
  //     ...
  //   }
  // and then you can use that reducer in both cases:
  //   dispatchComments({ type: "add", payload: comment });
  //   dispatchComments({ type: "delete", payload: id });
  // and you can also use it to sort the comments:
  //   dispatchComments({ type: "sort", payload: "score" });
  //   dispatchComments({ type: "sort", payload: "date" });
  //   dispatchComments({ type: "sort", payload: "score", order: "desc" });
  //   dispatchComments({ type: "sort", payload: "date", order: "desc" });
  // and then you'd have a commentsReducer function that handles all cases
  //   const commentsReducer = (state, action) => {
  //     switch (action.type) {
  //       case "add":
  //         return [...state, action.payload];
  //       case "delete":
  //         return state.filter((comment) => comment.id !== action.payload);
  //       case "sort":
  //         return state.sort((a, b) => {
  //           if (action.payload === "score") {
  //             return action.order === "desc"
  //               ? b.score - a.score
  //               : a.score - b.score;
  //           } else if (action.payload === "date") {
  //             return action.order === "desc"
  //               ? b.datePosted - a.datePosted
  //               : a.datePosted - b.datePosted;
  //           }
  //         });
  //       default:
  //         return state;
  //     }
  //   }
  // and then you can use that reducer in both cases:
  //   dispatchComments({ type: "add", payload: comment });
  //   dispatchComments({ type: "delete", payload: id });
  //   dispatchComments({ type: "sort", payload: "score" });
  //   dispatchComments({ type: "sort", payload: "date" });
  //   dispatchComments({ type: "sort", payload: "score", order: "desc" });
  //   dispatchComments({ type: "sort", payload: "date", order: "desc" });
  // will want to have comments sorted by default, so you'd need to do that in the useEffect hook
  //   useEffect(() => {
  //     dispatchComments({ type: "sort", payload: "date" });
  //   }, []);
  // but you can also do that without useEffect, by just sorting the comments in the initial state
  //   // sort by datePosted asc
  //   const [comments, dispatchComments] = useReducer(commentsReducer, initialComments.sort((a, b) => a.datePosted - b.datePosted));
  // or
  //   // sort by datePosted desc
  //   const [comments, dispatchComments] = useReducer(commentsReducer, initialComments.sort((a, b) => b.datePosted - a.datePosted));

  // a summary with types:
  //   type CommentsState = CommentAreaComment[];
  //   type CommentsAction =
  //     | { type: "add"; payload: CommentAreaComment }
  //     | { type: "delete"; payload: string }
  //     | { type: "sort"; payload: "score" | "date"; order?: "asc" | "desc" };
  //   const commentsReducer = (state: CommentsState, action: CommentsAction) => {
  //     switch (action.type) {
  //       case "add":
  //         return [...state, action.payload];
  //       case "delete":
  //         return state.filter((comment) => comment.id !== action.payload);
  //       case "sort":
  //         return state.sort((a, b) => {
  //           if (action.payload === "score") {
  //             return action.order === "desc"
  //               ? b.score - a.score
  //               : a.score - b.score;
  //           } else if (action.payload === "date") {
  //             return action.order === "desc"
  //               ? b.datePosted - a.datePosted
  //               : a.datePosted - b.datePosted;
  //           }
  //         });
  //       default:
  //         return state;
  //     }
  //   }
  //   // will need to sort the comments in the initial state
  //   const [comments, dispatchComments] = useReducer(commentsReducer, initialComments);
  //   // example usage:
  //   dispatchComments({ type: "add", payload: comment });
  //   dispatchComments({ type: "delete", payload: id });
  //   dispatchComments({ type: "sort", payload: "score" });
  //   dispatchComments({ type: "sort", payload: "date" });
  //   dispatchComments({ type: "sort", payload: "score", order: "desc" });
  //   dispatchComments({ type: "sort", payload: "date", order: "desc" });

  // using a reducer for remove/add is a bit overkill imo
  // but I think it's a good idea to use a reducer for sorting

  useEffect(() => {
    setComments(commentsQuery.data ?? []);
  }, [commentsQuery.data]);

  const deleteComment = api.comments.deleteComment.useMutation();

  const voteMutation = api.comments.vote.useMutation();

  const onCommentAdded = (comment: CommentType) => {
    // add comment to the top of the list
    setComments((prev) => [comment, ...prev]);
  };

  const onCommentDeleted = (id: string) => {
    // TODO?: error handling
    deleteComment.mutate({ id });

    setComments((prev) => prev.filter((comm) => comm.id !== id));
  };

  const onVote = (id: string, vote: "up" | "down") => {
    const comment = comments.find((comm) => comm.id === id);

    if (!comment) return;

    if (vote === "up") {
      const remove = comment.upvoted;

      if (remove) {
        // remove upvote
        comment.upvoted = false;
        comment.score -= 1;
      } else {
        // add upvote
        comment.upvoted = true;
        comment.score += comment.downvoted ? 2 : 1;
        comment.downvoted = false;
      }

      voteMutation.mutate({ id, vote, remove });
    } else {
      const remove = comment.downvoted;

      if (remove) {
        // remove downvote
        comment.downvoted = false;
        comment.score += 1;
      } else {
        // add downvote
        comment.downvoted = true;
        comment.score -= comment.upvoted ? 2 : 1;
        comment.upvoted = false;
      }

      voteMutation.mutate({ id, vote, remove });
    }
  };

  return (
    <section className="w-full space-y-4 max-lg:px-4 lg:w-1/2">
      {/* TODO?: scroll header thingy */}
      <h2 className="text-2xl font-semibold">Comments</h2>

      <NewCommentForm
        shoeId={shoeId}
        onCommentAdded={onCommentAdded}
        loading={commentsQuery.isInitialLoading}
      />

      <ul>
        {commentsQuery.isInitialLoading ? (
          <li>
            <div className="text-center">LOADING</div>
          </li>
        ) : (
          comments.map((comment) => (
            <li key={comment.id}>
              <Comment
                comment={comment}
                onDelete={onCommentDeleted}
                onVote={onVote}
              />
            </li>
          ))
        )}
      </ul>
    </section>
  );
}
